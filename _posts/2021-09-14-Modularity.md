# Modularity

Modularity is very important in engineering. If you can seperate a process into sub-processes, you can divide a problem that is impossible for a single human into a many problems that are manageable by groups of humans and one other problem which is to combine the solutions of the other problems together to solve the original problem. This clearly has very recursive properties. In programming, this is like having a function that is essentially just a list of function calls. The reason why a function written like this is so much easier to read is because you are just asking the reader to solve that one problem of putting all the subproblems together to solve the original problem. With no sub-functions, you are asking the reader to solve every problem all at once. Even if that function were written by one person, they might have in their mind seperated it into subproblems, but neglected to write the code in the way they thought about it so in effect you are reading code from a single thread perspective, when it was created by a multi-threaded perspective. This is why modularity in code and readable function names is really nice. However, another benefit of modularity is robustness and testability. By splitting a problem into a bunch of well defined sub-problems, you may test independently if each of your sub-problem solutions worked. The only thing that confounds this process is global variables. In the abstract, system states that effect the operation of either all or a subset of functions that solve subproblems. In humans, body temperature is a global variable. Every single function in your body uses your body temperature to guage what point in the circadium rhythm it is operating in. Different points in this rhythm require different functionoal behavior like sleeping versus exercising. However, there are also functions that regulate your body temperature. Your body uses the ammount of light that your body recieves to slowly shift your circadian rhythm over time to be in phase with the time shift. My question is this: if it is well known that global variables can have the effect of making a code base hard to edit, what properties of body temperature either make this problem not apply or at least make up for the problems of global variables? When are global variables good. It seems the answer is when the program relies on a concept of state or schedule.

This idea of splitting problems into subproblems goes beyond programming however. Mechanical designers have to do the same exact thing, just with physical functions. Thinking about it from this perspective puts another question in my mind. Of all the ways to break up problems into sub-problems how do you find the best way? When you have seperate individuals working on subproblems that arrive at issues in the implementation that arrise because of the specific way in which the problem was split how can you make sure that signal gets back to the designer so a better split can be used. The problem is that you often don't find these nasty problem spots until you start solving the subproblems. In other words it is hard for a designer to be God or to be computationally unbounded. Another problem arises when the formalization from the designer is not passed down to the sub-problem solvers perfectly. For example, one of the biggest problem spots on the Tesla model 3 production line was the glue mechanism that attatched a plastic shield to the battery packs. They spent a ton of time working this problem, but it was still holding up the production line. However, after taking a step back, they realized that the battery pack designers thought that the shield was included for noise muffling, and the acoustics engineers thought that the shield was included for battery fire safety. This shows how it can be difficult to perfectly split a problem, and to maintain alignment between subproblem solvers.